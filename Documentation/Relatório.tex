\documentclass[11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{todonotes}
\usepackage{url}

\begin{document}
\title{BananaCore - Processador em VHDL}
\author{
  Rogiel Sulzbach\\
  \and
  Jefferson Johner\\
  \and
  Matheus Oliveira\\
}

\maketitle
\tableofcontents

\chapter{Introdução}
\todo{Escrever capítulo de introdução}

O presente projeto versa sobre o processador BananaCore, desenvolvido como trabalho final da disciplina ENG04461 - Sistemas Digitais. Faz-se importante ressaltar que nosso processador foi desenvolvido com fins didáticos, não tentando priorizar desempenho ótimo.

\chapter{Especificação}

A especificação inicial para o nosso projeto consiste em um processador de arquitetura do tipo Von Neumann\footnote{A arquitetura Von Neumann consiste em uma única memória compartilhada tanto para dados como para programas.} de 16 bits com instruções básicas do tipo:

\begin{itemize}
	\item Operações de memória: Carregar dado da memória, armazenar dado na memória
	\item Operações aritméticas: adição, subtração, multiplicação e divisão
	\item Operações de IO: Write port e Read port
	\item Operações bit-a-bit: AND, NAND, OR, NOR, XOR e NOT
\end{itemize}

Como o objetivo do trabalho é desenvolver apenas um processador -- não estamos interessados em como armazenar o programa no FPGA -- escolhemos por gravar o programa de forma fixa; isto é, o programa é armazenado direto na memória RAM como um valor inicial.

Sabendo da limitação desta implementação, o design deve permitir que seja fácil substituir esta implementação inicial por outra mais funcional e completa.

\chapter{Implementação}

\section{Controlador de Memória}
\label{sec:MemoryController}
O controlador de memória é a unidade que faz o intermédio ao acesso a memória do processador.Nele, a operação de escrita é validada e então enviada para um respectivo memory bank (ver seção \ref{sec:MemoryBank}).

O controlador é operado utilizando $7$ sinais:

\begin{description}
	\item[Endereço (entrada)] Recebe um valor de 16 bits que representa o endereço que memória que se deseja operar
	\item[Leitura de dados (saída)] Retorna o valor equivalente ao byte armazenado no endereço solicitado ou alta impedância (caso esteja executando uma operação se escrita)
	\item[Escrita de dados (entrada)] Recebe o byte que deseja-se escrever na memória
	\item[Operação (entrada)] Indica a operação desejada na memória RAM (escrita ou leitura)
	\item[Pronto (saída)] Uma flag que indica que a operação de leitura/escrita foi concluída com sucesso.
\end{description}

\subsection{Leitura na memória RAM}
Para ler um byte da memória RAM, primeiramente seleciona-se o endereço desejado e atribui-se este valor ao barramento de endereços. Em seguida, o bit de operação é definido em modo leitura e aguarda-se um número arbitrário de clocks até que o sinal de pronto transicione para nível alto. No instante em que este sinal transiciona, o dado já está disponível na porta de leitura.

\subsection{Escrita na memória RAM}
Para escrever um byte na memória RAM, primeiramente seleciona-se o endereço desejado e atribui-se este valor ao barramento de endereços. Em seguida, no barramento de escrita de dados, o valor do byte é atribuido e o bit de operaçao é definido para uma operação do tipo \emph{WRITE}. Devido ao fato da memória RAM possuir um clock diferenciado do processador central, é necessário aguardar um intervalo arbitrário de ciclos de clock até que o sinal de pronto seja colocado em alto. Neste momento, já é possível iniciar a escrita do próximo byte da mesma maneira.

\subsection{Memory Bank}
\label{sec:MemoryBank}
O memory bank é uma entidade simples e serve como uma abstração para um módulo de memória RAM genérico. O otimizador do Quartus II, ao detectar a presença de um grande bloco de dados, automaticamente executa uma otimização e substitui este por um bloco de memória RAM.

\section{Controlador de Registrador}
Para evitar que fosse necessário injetar um grande número de sinais de acesso a dados, controle e status dos registradores, uma abstração semelhante ao acesso à memória foi criada para simplificar este desenvolvimento. Detalhes desta implementação serão omitidos, pois são muito semelhantes ao barramento de memória.

\section{Controlador de Instruções}
\label{sec:InstructionController}
O controlador de instruções é, sem dúvida, uma das partes com maior quantidade de código descrevendo hardware; isto se dá devido a uma dificuldade que encontramos ao implementar um barramento único de acesso à memória e aos registradores.

\subsection{Decodificador de instruções}
\todo{Detalhar a implementação atual}

\subsection{Executor de instruções}
\label{sec:InstructionExecutor}
Cada instrução foi dividida em uma entidade chamada de \emph{executor}. Esta entidade é responsável por fazer o carregamento de dados, execução da instrução e armazenamento do resultado final. Devido a repetição de código nestes executores, utilizamos geradores para gerar grande parte do código de forma automática e simples (ver seção \ref{sec:CodeGeneration}).

\subsection{Acesso à memória}
\label{sec:MemoryAccess}

Inicialmente, pretendíamos implementar o acesso global a memória por via de um barramento delimitado por \emph{buffers tri-state}, contudo, esta implementação se mostrou muito complexa, pois ao incrementar as implementações de instruções do processador o barramento entrava em um estado inválido pois mais de dois sinais tentavam ser escritos no barramento em simultâneo. Acreditamos que estes problemas são devidos a falhas de design da arquitetura e que poderiam ser resolvidas escolhendo uma forma alternativa de implementação das instruções.

A solução desde problema, embora não seja ideal, foi simples: um grande MUX foi implementado de forma a fazer o "controle" de acesso ao barramento principal. Esta solução tem um grave problema: a necessidade de escrever código cresce muito em função da quantidade de instruções implementadas. Para um processador simples como o BananaCore isto pode não ser um problema muito relevante. Para implementações maiores, porém, isto pode ganhar uma faceta muito mais adversa. Como forma de solucionar, parcialmente, este empecilho, fizemos uso de artefatos de geração de código para gerar os muxes e demais condições do decodificador de instruções (ver seção \ref{sec:CodeGeneration}).

\todo{Detalhar a implementação atual}

\section{Geração de código}
\label{sec:CodeGeneration}
Para gerar os códigos repetitivos e forma algorítmica, fizemos usos de duas ferramentas distintas: Cog\footnote{Cog é um aplicativo que executa programas Python contidos em comentários do código fonte e substitui sua saída ao final da execução. O programa está disponível publicamente \mbox{em \url{http://nedbatchelder.com/code/cog/}}} e um script personalizado de geração de executores de instruções.

Mais detalhes da geração de código podem ser extraídas do código fonte do projeto disponível no GitHub.


\section{Especificação final}
A especificação final para o nosso projeto consiste em um processador de arquitetura do tipo Von Neumann\footnote{A arquitetura Von Neumann consiste em uma única memória compartilhada tanto para dados como para programas.} de 16 bits com instruções básicas do tipo:

\begin{itemize}
	\item Operações de memória: Carregar dado da memória, armazenar dado na memória
	\item Operações aritméticas: adição, subtração, multiplicação e divisão
	\item Operações de IO: Write port e Read port
	\item Operações bit-a-bit: AND, NAND, OR, NOR, XOR e NOT
\end{itemize}

\todo{Escrever sobre os registradores}

\chapter{Testes}
\todo{Escrever capítulo de testes}

\chapter{Melhoramentos futuros}
\section*{Tempos de espera redundantes}
Na implementação atual, o processador gasta muitos ciclos de clock esperando por sinais internos. Muitas destas esperas podem ser removidas ou simplificadas.

\section*{Aglutinação de leituras consecutivas}
Também, é possível aglutinar operações de forma simultânea. Por exemplo, é possível reduzir um ciclo de clock a cada leitura de 2 bytes consecutivos da memória ao iniciar a leitura do próximo imediatamente após a finalização da leitura anterior.

\section*{Acesso a memória em palavras maiores}
Para melhorar a performance é possível aumentar o tamanho da palavra retornada pelo controlador de memória. Atualmente o controlador retorna palavras com 8 bits. Este limite pode ser aumentado (ou configurável) de forma a permitir que seja possível ler mais bytes em apenas uma solicitação.

\section*{Ineficiência do divisor}
Após a análise de "slow-model" to TimeQuest, percebe-se claramente que o caminho crítico do processador está no divisor. Ele é responsável por um circuito síncrono, isto faz com que o clock do processador inteiro seja delimitado pelo clock deste caminho crítico. Uma possível solução seria implementar pipeline no cálculo da divisão para segmentar este caminho crítico em múltiplos caminhos menores.

\section*{Controlador de clock interno}
Se possível na placa de desenvolvimento, a criação de um controlador de clock interno permitiria que o clock fosse ajustado para velocidade mínima necessária no momento, bem como permitiria a redução (ou total desligamento) do clock do processador para economia de energia ou dissipação de calor.

\section*{Controlador de interrupções}
Uma futura melhoria interessante é a adição de interrupções por timers e externas.

\chapter{Conclusão}
\todo{Escrever capítulo de conclusão}

O processador é, dos componentes de um computador ou sistema digital, o componente mais caro e complexo. Trata-se de uma poderosa máquina de calcular.Tendo em vista sua função e complexidade, conclui-se que como projeto de conclusão de disciplina um processador é um elemento extremamente adequado, abordando grande parte dos conceitos estudados durante o semestre.

\end{document}
